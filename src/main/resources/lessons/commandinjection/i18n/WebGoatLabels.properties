commandinjection.title=Command Injection
commandinjection.task1.hint1=Look at the command preview; it shows exactly what the server runs.
commandinjection.task1.hint2=Submitting the command string proves you understand the wrapper. Try combining dropdown and custom input.
commandinjection.task1.success=Command recognised! Now that you know the wrapper, plan your payloads.
commandinjection.task1.failure.empty=Paste the command string you observed before submitting.
commandinjection.task1.failure.mismatch=The observed command does not match what was executed. Check the preview again.
commandinjection.safety.hint1=This lesson runs shell commands. If possible use the Docker container to stay isolated.
commandinjection.safety.success=Thanks for acknowledging the risk. Continue to the diagnostics console.
commandinjection.safety.failure=Please type the exact acknowledgement before proceeding.
commandinjection.task2.hint1=Start with the same diagnostic command the service expects, then chain your payload (e.g., using ; or &&).
commandinjection.task2.hint2=Chain a command that echoes WEBGOAT_BUILD_TOKEN (e.g., ; echo $WEBGOAT_BUILD_TOKEN or && echo %WEBGOAT_BUILD_TOKEN%) and submit the value it prints.
commandinjection.task2.success=Great! You chained commands and leaked the token.
commandinjection.task2.failure.blank=Provide the build token from the command output.
commandinjection.task2.failure.mismatch=That token does not match the leaked value. Try again.
commandinjection.task3.hint1=Start with a normal search (e.g., Luna) to see how grep $title images/* maps to the cat metadata files.
commandinjection.task3.hint2=The flag lives in command-injection/<username>/flag.txt. When the working directory is set up for you, that file is reachable as plain flag.txt, so use cat/type after your search to dump it.
commandinjection.task3.hint3=Keep the grep happy by injecting the images/* glob before your separator; otherwise grep waits on STDIN and times out.
commandinjection.task3.hint4=After cat prints the flag, comment out the template tail (e.g., ; #) so the extra images/* from the wrapper does not run. Submit the token.
commandinjection.task3.success=Flag captured! You now have proof the shell executes arbitrary commands.
commandinjection.task3.failure.blank=Fetch the flag token from the output before submitting.
commandinjection.task3.failure.invalid=That token does not match the flag. Try executing the cat command again.
commandinjection.task3.failure.payload=Enter a cat name (or your exploit) before running the search.
commandinjection.task4.hint1=The app now strips ;, &&, and | from your payload before running grep, but it still shells out.
commandinjection.task4.hint2=Use a different separator: command substitution like $(cat api-key.txt) or a newline survives the filter.
commandinjection.task4.hint3=Try command substitution (e.g., $(cat api-key.txt)) or even a newline to bypass the denylist.
commandinjection.task4.hint4=Remember the working directory already contains api-key.txt, so reference it directly and paste the full API_KEY=â€¦ value into the form.
commandinjection.task4.success=Great! The denylist did not stop you from leaking the API key.
commandinjection.task4.failure.blank=Provide the API key you retrieved before submitting.
commandinjection.task4.failure.invalid=That key does not match the stored value. Double-check your payload.
commandinjection.task4.failure.payload=Enter a cat name or exploit payload before running the search.
commandinjection.task5.hint1=Shell execution keeps the same attack surface look for an option that avoids /bin/sh entirely.
commandinjection.task5.hint2=Start by enabling the command allowlist so the diagnostics command still runs.
commandinjection.task5.hint3=Sanitising is a nice defense in depth, but the real fix is removing the shell and enforcing the allowlist.
commandinjection.task5.hint4=Combine direct process execution (or allowlist-only) with the allowlist so status works but injection fails.
commandinjection.task5.success=Configuration hardened! Removing the shell and enforcing the allowlist blocks injection while diagnostics still run.
commandinjection.task5.failure.both=This setup blocks the status command and still allows the exploit.
commandinjection.task5.failure.status=The diagnostics command no longer works. Try enabling the allowlist.
commandinjection.task5.failure.injection=Injection still succeeds. Remove the shell and enforce the allowlist.
commandinjection.task5.failure.generic=That configuration is not secure yet.
commandinjection.task5.failure.shell=Close! You still rely on the shell to switch to direct process or allowlist-only execution.
commandinjection.task5.remediation=Prefer a shell-less runner with a strict allowlist so only approved diagnostics execute.
